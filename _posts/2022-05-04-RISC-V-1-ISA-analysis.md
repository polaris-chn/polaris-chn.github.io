---
layout: post
title: RISC-V指令集分析
categories: RISC-V CA
description: 对于RISC-V指令集的分析
keywords: RISC-V 指令集
---

# RISC-V指令集分析

## 背景
RISC-V指令集作为当前最新最流行的开源指令集，吸收了之前出现的指令集的优点，并极力避免了一些不足，创造性地使用了模块化指令集的概念，使得基于RISC-V指令集设计的芯片既可以用于极低功耗的嵌入式环境，也可用于高性能高带宽的业务场景，所以RISC-V具有广阔的应用市场和发展前景。本项目希望设计一个基于RV64I指令集的CPU，加强对于RISC-V的认知和理解。RV64I是64位架构的整数指令集，其是整个RISC-V指令集的一个子集，也是RV32I指令集的超集，也就是说RV64I是在RV32I的基础上发展而来，在后面具体的指令集分析时候，也可以看出来。设计CPU的第一步就是对于指令集的分析，本篇文章就是对于RV64I指令集的一个简单分析。

## RV64I
首先需要明确一点，RV64I和RV32I的指令宽度都是32bit。RV64I共有64条指令，包括59条基本指令，5条特权指令。59条基本指令中包括47条从RV32I指令发展而来的基本指令，这些指令大部分RV64I和RV32I通用，有小部分有细微差别；还包括12条RV64I独有的指令，具体的指令分析如下所示。

### R型指令
R型指令的格式如下所示:

|31~25|24~20|19~15|14~12|11~7|6~0|
|---|:---:|:---:|:---:|:---:|:---:|
|func7|rs2|rs1|func3|rd|opcode|

具体指令格式则如下所示：

#### RV32I & RV64I

|指令|func7|rs2|rs1|func3|rd|opcode|操作|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|add    |0000000|rs2|rs1|000|rd|0110011|加法，x[rd]=x[rs1] + x[rs2]，忽略算术溢出|
|sub    |0100000|rs2|rs1|000|rd|0110011|减法，x[rd]=x[rs1] - x[rs2]，忽略算术溢出|
|sll    |0000000|rs2|rs1|001|rd|0110011|逻辑左移，x[rd]=x[rs1] << x[rs2]，低位填0，RV64I中rs2低6位代表移位个数，忽略高位|
|srl    |0000000|rs2|rs1|101|rd|0110011|逻辑右移，x[rd]=x[rs1] >> u x[rs2]，高位填0，RV64I中rs2低6位代表移位个数，忽略高位|
|sra    |0100000|rs2|rs1|101|rd|0110011|算术右移，x[rd]=x[rs1] >> s x[rs2]，高位填rs1最高位，RV64I中rs2低6位代表移位个数，忽略高位|
|slt    |0000000|rs2|rs1|010|rd|0110011|小于置位，若x[rs1] < s x[rs2]，x[rd]为1，否则为0|
|sltu   |0000000|rs2|rs1|011|rd|0110011|无符号小于置位，若x[rs1] < u x[rs2]，x[rd]为1，否则为0|
|and    |0000000|rs2|rs1|111|rd|0110011|x[rd]=x[rs1] & x[rs2]，位与|
|or     |0000000|rs2|rs1|110|rd|0110011|x[rd]=x[rs1] &#124; x[rs2]，位或|
|xor    |0000000|rs2|rs1|100|rd|0110011|x[rd]=x[rs1] ^ x[rs2]，位异或|

#### RV64I

|指令|func7|rs2|rs1|func3|rd|opcode|操作|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|addw   |0000000|rs2|rs1|000|rd|0111011|x[rd]=sext((x[rs1] + x[rs2])[31:0])，截取rs1和rs2加和的低32bit，对其符号扩展写入xd|
|subw   |0100000|rs2|rs1|000|rd|0111011|x[rd]=sext((x[rs1] - x[rs2])[31:0])，截取rs1和rs2差的低32bit，对其符号扩展写入xd|
|sllw   |0000000|rs2|rs1|001|rd|0111011|x[rd]=sext((x[rs1] << x[rs2][4:0])[31:0])，rs1低32bit逻辑左移，低位填0，rs2低5位为移动位数|
|srlw   |0000000|rs2|rs1|101|rd|0111011|x[rd]=sext(x[rs1][31:0] >>u x[rs2][4:0])，rs1低32bit逻辑右移，高位填0，rs2低5位为移动位数|
|sraw   |0100000|rs2|rs1|101|rd|0111011|x[rd]=sext(x[rs1][31:0] >>s x[rs2][4:0])，rs1低32bit算术右移，高位填rs1[31]，rs2低5位为移动位数|


### J型指令
属于RV31I和RV64I的J型指令只有一条，其格式如下所示:

|31|30~21|20|19~12|11~7|6~0|
|---|:---:|:---:|:---:|:---:|:---:|
|imm[20]|imm[10:1]|imm[11]|imm[19:12]|rd|opcode|

具体指令格式则如下所示：

#### RV32I & RV64I

|指令|imm[20]|imm[10:1]|imm[11]|imm[19:12]|rd|opcode|操作|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|jal|imm[20]|imm[10:1]|imm[11]|imm[19:12]|rd|1101111|x[rd]=pc+4; pc+=sext(imm)，跳转立即数加pc的地址，并将pc+4数值存入rd，rd默认为x1|


### U型指令
属于RV31I和RV64I的U型指令只有两条，其格式如下所示:

|31~12|11~7|6~0|
|---|:---:|:---:|
|imm[31:12]|rd|opcode|

具体指令格式则如下所示：

#### RV32I & RV64I

|指令|imm[31:12]|rd|opcode|操作|
|---|:---:|:---:|:---:|:---:|
|lui    |imm[31:12]|rd|0110111|x[rd]=sext(imm[31:12] << 12)，20bit立即数逻辑左移，低位填0，符号扩展之后写入rd|
|auipc  |imm[31:12]|rd|0010111|x[rd]=pc+sext(imm[31:12] << 12，20bit立即数逻辑左移，低位填0，符号扩展之后加上pc，写入rd)|


### S型指令
S型指令格式如下所示:

|31~25|24~20|19~15|14~12|11~7|6~0|
|---|:---:|:---:|:---:|:---:|:---:|
|imm[11:5]|rs2|rs1|func3|imm[4:0]|opcode|

具体指令格式则如下所示：

#### RV32I & RV64I

|指令|imm[11:5]|rs2|rs1|func3|imm[4:0]|opcode|操作|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|sb|imm[11:5]|rs2|rs1|000|imm[4:0]|0100011|M[x[rs1]+sext(imm)]=x[rs2][7:0]，将rs2的低8位存入到内存|
|sh|imm[11:5]|rs2|rs1|001|imm[4:0]|0100011|M[x[rs1]+sext(imm)]=x[rs2][15:0]，将rs2的低16位存入到内存|
|sw|imm[11:5]|rs2|rs1|010|imm[4:0]|0100011|M[x[rs1]+sext(imm)]=x[rs2][31:0]，将rs2的低32位存入到内存|

#### RV64I

|指令|imm[11:5]|rs2|rs1|func3|imm[4:0]|opcode|操作|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|sd|imm[11:5]|rs2|rs1|011|imm[4:0]|0100011|M[x[rs1]+sext(imm)]=x[rs2][63:0]，将rs2的低32位存入到内存|


### B型指令
S型指令格式如下所示:

|31|30~25|24~20|19~15|14~12|11~8|7|6~0|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|imm[12]|imm[10:5]|rs2|rs1|func3|imm[4:1]|imm[11]|opcode|

具体指令格式则如下所示：

#### RV32I & RV64I

|指令|imm[12]|imm[10:5]|rs2|rs1|func3|imm[4:1]|imm[11]|opcode|操作|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|beq    |imm[12]|[10:5]|rs2|rs1|000|[4:1]|[11]|1100011|if (rs1 == rs2) pc += sext(imm)|
|bne    |imm[12]|[10:5]|rs2|rs1|001|[4:1]|[11]|1100011|if (rs1 != rs2) pc += sext(imm)|
|blt    |imm[12]|[10:5]|rs2|rs1|100|[4:1]|[11]|1100011|if (rs1 < rs2) pc += sext(imm)，x[rs1]和x[rs2]为有符号数|
|bltu   |imm[12]|[10:5]|rs2|rs1|110|[4:1]|[11]|1100011|if (rs1 < rs2) pc += sext(imm)，x[rs1]和x[rs2]为无符号数|
|bge    |imm[12]|[10:5]|rs2|rs1|101|[4:1]|[11]|1100011|if (rs1 >= rs2) pc += sext(imm)，x[rs1]和x[rs2]为有符号数|
|bgeu   |imm[12]|[10:5]|rs2|rs1|111|[4:1]|[11]|1100011|if (rs1 >= rs2) pc += sext(imm)，x[rs1]和x[rs2]为无符号数|